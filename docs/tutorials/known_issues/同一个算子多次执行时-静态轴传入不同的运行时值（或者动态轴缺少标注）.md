# 同一个算子多次执行时，静态轴传入不同的运行时值（或者动态轴缺少标注）

## 问题现象描述

精度错误，或者AI CPU/AI Core异常。

## 可能原因

由于编译时会针对静态轴进行固定大小的切分，因此切分的数量也是固定的。这意味着一次编译后的代码只能处理一个特定的静态轴。如果传入的静态轴与首次编译时的不一致，切分后访问的内存地址可能会超出实际传入的Tensor的大小，导致内存访问错误，或对其他Tensor造成干扰，从而引发精度异常。

## 处理步骤

-   方案1：针对每一次不同的静态值，定义不同的算子。

    ```python
    def handler(in): # 定义公共处理函数
        return pypto.add(in, in)
    
    @pypto.jit
    def adder_256(in_shape_256): # 定义处理in 轴大小是256的场景
        return handler(in_shape_256)
    
    @pypto.jit
    def adder_1024(in_shape_1024): # 定义处理 in 轴大小是 1024 的算子
        return handler(in_shape_1024)
    
    adder_256(in_256)
    adder_1024(in_1024)
    ```

-   方案2：定义为动态轴

    ```python
    @pypto.jit
    def adder(in_shape): # 定义处理in 轴大小是256的场景
        out = Tensor(in_shape.shape[0])
        for k in pypto.loop(in_shape.shape[0] / 256):
            out[k * 256: k *256 + 256] = pypto.add(
                in[k * 256 : k * 256 + 256],
                in[k * 256 : k * 256 + 256])
        return handler(in_shape_256)
    ```

