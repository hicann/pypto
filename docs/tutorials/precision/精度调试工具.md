# 精度调试工具

## 工具简介

PyPTO在计算图编译的各Pass阶段拥有完整的中间表示，可翻译成第三方计算代码，并在其它计算单元（例如Host CPU）上模拟计算过程。该工具通过模拟计算结果与基准数据的误差对比，可以检测算子异常或者某个Pass的处理结果是否存在异常，并定位首个出现异常的计算节点。

主要特性及使用场景：

-   自检：用于自检Pass的正确性。基于各Pass模拟计算的结果，对比检测Pass正确性及异常计算节点。常用于以下情况：
    -   当用户算子精度刚刚出现问题且没有明确方向，可先使能自检特性排除Pass处理阶段是否引入潜在错误。
    -   当用户大致明确某个Pass出问题时，使能自检特性获取该Pass及前序Pass的模拟计算中间数据，对比数据找出潜在出问题的计算操作。

-   粗检：用于粗检算子代码、框架前端处理的正确性。基于用户提供的基准（golden）输入输出数据，与Tensor Graph模拟计算的最终结果对比检测整体计算的正确性。常用于以下情况：
    -   当用户存在可用的算子基准（golden）输入、输出数据时，可先使能粗检特性粗略排除算子代码、框架前端处理是否引入差异。

-   人工调测：指定单个计算结果，保存到文件或者以可读形式打印到输出、日志。
    -   当用户的数据异常为典型的连续非法值、连续异常0值时，可使能自检开关并使用pass\_verify\_print/pass\_verify\_save特性打印、保存存疑的模拟数据，逐步人工检查找到首个发生异常的计算代码行。
    -   当用户存在可用的算子基准（golden）中间数据、且中间数据可与PyPTO算子的相应计算直接对应时，可使能自建开关并使用pass\_verify\_print/pass\_verify\_save 特性打印、保存可对应的数据，人工对比检查找到首个发生异常的计算代码行。

## 使用约束

当前精度调试工具存在以下限制（完整计算流表示仅保存在pass运行上下文中），无法使用检测功能：

-   不支持上板执行的中间数据检查，仅支持前端及pass的检查。
-   不支持集合通信场景。
-   不支持特定pass，特定pass（例如SubgraphToFunction）属于中间的优化过程缺少完整计算信息，工具内部做自动跳过处理。
-   不支持pass间的自动对比校验（需人工进行数据对比）。
-   不支持程序退出后在任意运行环境构造并模拟计算。需在算子编译期间，所对应的主机CPU及进程上构造并模拟计算。
-   不支持基于昇腾AI处理器调用Ascend C构造并模拟计算。
-   不支持基于GPU构造并模拟计算。

## 环境准备

需要重新编译并安装PyPTO后才能使用该工具。

1.  确认GCC安装并升级到9.4.0或更高版本。
2.  重新通过源码编译安装PyPTO。主要区别是在编译安装命令中增加选项 --no-build-isolation，其他操作请参见[编译安装](../../context/prepare_environment.md)。

    ```bash
    python3 -m pip install . --verbose --no-build-isolation
    ```

## 自检操作步骤

1.  开启精度调试开关。（基础用例：examples/01\_beginner/00\_introduction/add\_direct.py）

    ```python
    ...
    verify_options = {
        "enable_pass_verify": True,
        "pass_verify_save_tensor": True,
        ...
    }
    
    @pypto.jit(verify_options=verify_options)
    def add_kernel(input0: pypto.Tensor, input1: pypto.Tensor, output: pypto.Tensor):
        pypto.set_vec_tile_shapes(1, 4, 1, 64)
        output[:] = input0 + input1
    
    ...
    ```

2.  执行修改后用例。

    ```bash
    python3 examples/01_beginner/00_introduction/add_direct.py
    ```

    打印类似以下输出，指示对应的自检结果为通过（PASS）、未通过（FAIL\(ED\)）或跳过校验（NO\_COMPARE）：

    ```txt
    2025-mm-dd HH:MM:SS:xxx V | tensor_graph Verify NO_COPARE
    2025-mm-dd HH:MM:SS:xxx V | function_TENSOR_loop_0_Unroll1_PATH0_hiddenfunc0_8.pass_00_RemoveRedundantReshape Verify result PASS
    2025-mm-dd HH:MM:SS:xxx V | function_TENSOR_loop_0_Unroll1_PATH0_hiddenfunc0_8.pass_01_AutoCast Verify result PASS
    2025-mm-dd HH:MM:SS:xxx V | function_TENSOR_loop_0_Unroll1_PATH0_hiddenfunc0_8.pass_02_InferMemoryConflict Verify result PASS
    ...
    2025-mm-dd HH:MM:SS:xxx V | function_TENSOR_loop_0_Unroll1_PATH0_hiddenfunc0_8.pass_34_InsertSync Verify result PASS
    2025-mm-dd HH:MM:SS:xxx V | function_TENSOR_loop_0_Unroll1_PATH0_hiddenfunc0_8.pass_35_MixSubgraphSplit Verify result PASS
    2025-mm-dd HH:MM:SS:xxx V | function_TENSOR_loop_0_Unroll1_PATH0_hiddenfunc0_8.pass_36_CodegenPreproc Verify result PASS
    ```

3.  执行结束后，在$\{work\_path\}/output/output\_\*/目录（\*代表时间戳）下生成verify\_\*目录，存放检测结果文件。

    ```txt
    ├── tensor_graph # 保存前端初始计算图模拟计算后的中间数据，作为基础数据
    │   ├── *.data 
    │   └── ...
    ├── verify_result.csv # 结果报告，用于保存中间数据的元数据信息、元数据对应的数据文件名、对其中属于Tensor数据的文件进行自检的结果
    ├── {FUNC_NAME}.pass_{PASS_SEQ}_{PASS_NAME} # 保存中间pass计算图模拟计算后的中间数据，作为待测数据
    │   ├── *.data 
    │   └── ...
    ```

4.  查看结果报告文件verify\_result.csv，如下图所示。

    ![](../figures/zh-cn_image_0000002532891719.png)

    **表 1**  结果报告文件参数说明

    
    <table><thead align="left"><tr id="row2359141665114"><th class="cellrowborder" valign="top" width="33.26%" id="mcps1.2.3.1.1"><p id="p153591716125110">参数</p>
    </th>
    <th class="cellrowborder" valign="top" width="66.74%" id="mcps1.2.3.1.2"><p id="p153595162517">说明</p>
    </th>
    </tr>
    </thead>
    <tbody><tr id="row9359101655119"><td class="cellrowborder" valign="top" width="33.26%" headers="mcps1.2.3.1.1 "><p id="p103605166517">No.</p>
    </td>
    <td class="cellrowborder" valign="top" width="66.74%" headers="mcps1.2.3.1.2 "><p id="p158261434195112">单个Pass内的数据顺序编号，例如1。</p>
    </td>
    </tr>
    <tr id="row1436011685116"><td class="cellrowborder" valign="top" width="33.26%" headers="mcps1.2.3.1.1 "><p id="p18360171615519">rootFuncID</p>
    </td>
    <td class="cellrowborder" valign="top" width="66.74%" headers="mcps1.2.3.1.2 "><p id="p124994461581">Root Function节点的唯一标识</p>
    </td>
    </tr>
    <tr id="row20360131655115"><td class="cellrowborder" valign="top" width="33.26%" headers="mcps1.2.3.1.1 "><p id="p83601016185115">funcID</p>
    </td>
    <td class="cellrowborder" valign="top" width="66.74%" headers="mcps1.2.3.1.2 "><p id="p11591552173116">Function节点的唯一标识</p>
    </td>
    </tr>
    <tr id="row1236001614514"><td class="cellrowborder" valign="top" width="33.26%" headers="mcps1.2.3.1.1 "><p id="p83600167511">verifyType</p>
    </td>
    <td class="cellrowborder" valign="top" width="66.74%" headers="mcps1.2.3.1.2 "><p id="p186251529362">算子信息及数据对应的pass名称，格式为：</p>
    <p id="p836001611515">* {FUNC_NAME}.pass_{PASS_SEQ}_{PASS_NAME}</p>
    <p id="p146941149205817">示例为：function_TENSOR_LOOP_L1_Unroll1_PATH1_7.pass_06_SplitReshape</p>
    </td>
    </tr>
    <tr id="row193601216115112"><td class="cellrowborder" valign="top" width="33.26%" headers="mcps1.2.3.1.1 "><p id="p6360111645116">LoopInfo</p>
    </td>
    <td class="cellrowborder" valign="top" width="66.74%" headers="mcps1.2.3.1.2 "><p id="p1036081635115">控制流信息，例如s_idx=2@b_idx=1</p>
    </td>
    </tr>
    <tr id="row16360181645113"><td class="cellrowborder" valign="top" width="33.26%" headers="mcps1.2.3.1.1 "><p id="p173601216125112">opCode</p>
    </td>
    <td class="cellrowborder" valign="top" width="66.74%" headers="mcps1.2.3.1.2 "><p id="p877833391716">Tile算子名称</p>
    </td>
    </tr>
    <tr id="row193604167518"><td class="cellrowborder" valign="top" width="33.26%" headers="mcps1.2.3.1.1 "><p id="p336051615115">opMagic</p>
    </td>
    <td class="cellrowborder" valign="top" width="66.74%" headers="mcps1.2.3.1.2 "><p id="p10522025133212">Operation节点的唯一标识</p>
    </td>
    </tr>
    <tr id="row183608168519"><td class="cellrowborder" valign="top" width="33.26%" headers="mcps1.2.3.1.1 "><p id="p19360111618514">tensorMagic</p>
    </td>
    <td class="cellrowborder" valign="top" width="66.74%" headers="mcps1.2.3.1.2 "><p id="p514218533321">Tensor的唯一标识</p>
    </td>
    </tr>
    <tr id="row13360716195114"><td class="cellrowborder" valign="top" width="33.26%" headers="mcps1.2.3.1.1 "><p id="p1236191655110">rawTensorMagic</p>
    </td>
    <td class="cellrowborder" valign="top" width="66.74%" headers="mcps1.2.3.1.2 "><p id="p139291879337">Tensor节点所属物理内存区域Raw Tensor的唯一标识。</p>
    </td>
    </tr>
    <tr id="row336141645110"><td class="cellrowborder" valign="top" width="33.26%" headers="mcps1.2.3.1.1 "><p id="p10361131618513">offset</p>
    </td>
    <td class="cellrowborder" valign="top" width="66.74%" headers="mcps1.2.3.1.2 "><p id="p1450731512396">当前Tensor在rawTensor内存中的偏移量，为整数数组。</p>
    </td>
    </tr>
    <tr id="row1736181614518"><td class="cellrowborder" valign="top" width="33.26%" headers="mcps1.2.3.1.1 "><p id="p15361191612518">inputShape</p>
    </td>
    <td class="cellrowborder" valign="top" width="66.74%" headers="mcps1.2.3.1.2 "><p id="p4435122013399">输入Tensor节点的形状信息，为整数数组。</p>
    </td>
    </tr>
    <tr id="row1636131665119"><td class="cellrowborder" valign="top" width="33.26%" headers="mcps1.2.3.1.1 "><p id="p1536151635117">inputValidShape</p>
    </td>
    <td class="cellrowborder" valign="top" width="66.74%" headers="mcps1.2.3.1.2 "><p id="p08401622153417">输入Tensor节点实际数据大小的形状信息，为整数数组。</p>
    </td>
    </tr>
    <tr id="row14361616185118"><td class="cellrowborder" valign="top" width="33.26%" headers="mcps1.2.3.1.1 "><p id="p183611616175114">inputDtype</p>
    </td>
    <td class="cellrowborder" valign="top" width="66.74%" headers="mcps1.2.3.1.2 "><p id="p3261181281715">输入数据类型</p>
    </td>
    </tr>
    <tr id="row03611416145112"><td class="cellrowborder" valign="top" width="33.26%" headers="mcps1.2.3.1.1 "><p id="p123611616115114">inputTensors</p>
    </td>
    <td class="cellrowborder" valign="top" width="66.74%" headers="mcps1.2.3.1.2 "><p id="p183611216125117">Tile算子的输入tile tensor对应的数据文件名列表，当前不支持文件落盘。</p>
    </td>
    </tr>
    <tr id="row7361181618514"><td class="cellrowborder" valign="top" width="33.26%" headers="mcps1.2.3.1.1 "><p id="p17361116105117">outputShape</p>
    </td>
    <td class="cellrowborder" valign="top" width="66.74%" headers="mcps1.2.3.1.2 "><p id="p16541622163511">输出Tensor节点的形状信息，为整数数组。</p>
    </td>
    </tr>
    <tr id="row1036219168516"><td class="cellrowborder" valign="top" width="33.26%" headers="mcps1.2.3.1.1 "><p id="p15362316155112">outputValidShape</p>
    </td>
    <td class="cellrowborder" valign="top" width="66.74%" headers="mcps1.2.3.1.2 "><p id="p1954122283511">输出Tensor节点实际数据大小的形状信息，为整数数组。</p>
    </td>
    </tr>
    <tr id="row14362216175118"><td class="cellrowborder" valign="top" width="33.26%" headers="mcps1.2.3.1.1 "><p id="p83620169510">outputDynValidShape</p>
    </td>
    <td class="cellrowborder" valign="top" width="66.74%" headers="mcps1.2.3.1.2 "><p id="p1542102253516">输出Tensor节点中实际数据大小的动态形状信息，为整数数组。</p>
    </td>
    </tr>
    <tr id="row4362151616518"><td class="cellrowborder" valign="top" width="33.26%" headers="mcps1.2.3.1.1 "><p id="p7362116125120">outputDtype</p>
    </td>
    <td class="cellrowborder" valign="top" width="66.74%" headers="mcps1.2.3.1.2 "><p id="p11616112893520">输出数据类型</p>
    </td>
    </tr>
    <tr id="row136214163514"><td class="cellrowborder" valign="top" width="33.26%" headers="mcps1.2.3.1.1 "><p id="p143621164519">outputTensor</p>
    </td>
    <td class="cellrowborder" valign="top" width="66.74%" headers="mcps1.2.3.1.2 "><p id="p1836220167513">tile算子的输出tile tensor对应的数据文件名，例如：5~10003~s_idx=2@b_idx=1~7~10007~MUL~16~17~1765890242967069.data</p>
    <p id="p17674165410127">该列表生成在${work_path}/output/output_*/目录下。</p>
    <p id="p067415415124">文件名格式定义如下：{ROOT_FN_ID}~{CALL_OP_ID}~{LOOP_INFO}~{LEAF_FN_ID}~{OP_ID}~{OP_NAME}~{TENSOR_ID}~{TILE_TENSOR_ID}~{TIMESTAMP}.data</p>
    <p id="p1367435491213">文件内容格式如下：Tensor数据的直接内存转储（endianness遵循主机CPU所使用的规则，例如x86 CPU通常为little-endian）</p>
    </td>
    </tr>
    <tr id="row14362716205117"><td class="cellrowborder" valign="top" width="33.26%" headers="mcps1.2.3.1.1 "><p id="p16362101611513">verifyResult</p>
    </td>
    <td class="cellrowborder" valign="top" width="66.74%" headers="mcps1.2.3.1.2 "><p id="p16362116205119">对比检测的结果：</p>
    <ul id="ul18923125616714"><li>粗检模式：用户golden与模拟计算最终输出的结果比较。</li><li>自检模式：tensor graph中间模拟输出与其它pass中间模拟输出的结果比较。</li></ul>
    </td>
    </tr>
    <tr id="row153621016185110"><td class="cellrowborder" valign="top" width="33.26%" headers="mcps1.2.3.1.1 "><p id="p8362151635115">maxAbsDiff</p>
    </td>
    <td class="cellrowborder" valign="top" width="66.74%" headers="mcps1.2.3.1.2 "><p id="p19362216175114">误差信息：最大绝对误差</p>
    </td>
    </tr>
    <tr id="row123621916105118"><td class="cellrowborder" valign="top" width="33.26%" headers="mcps1.2.3.1.1 "><p id="p836221655118">maxRelDiff</p>
    </td>
    <td class="cellrowborder" valign="top" width="66.74%" headers="mcps1.2.3.1.2 "><p id="p12362101613512">误差信息：最大相对误差</p>
    </td>
    </tr>
    <tr id="row23621616185111"><td class="cellrowborder" valign="top" width="33.26%" headers="mcps1.2.3.1.1 "><p id="p17362161655112">errorCount</p>
    </td>
    <td class="cellrowborder" valign="top" width="66.74%" headers="mcps1.2.3.1.2 "><p id="p436201645119">误差信息：实际错误数量N_err</p>
    </td>
    </tr>
    <tr id="row3362171610518"><td class="cellrowborder" valign="top" width="33.26%" headers="mcps1.2.3.1.1 "><p id="p2036214163518">errorRatio</p>
    </td>
    <td class="cellrowborder" valign="top" width="66.74%" headers="mcps1.2.3.1.2 "><p id="p13621716195111">误差信息：实际错误数占比R</p>
    <p id="p35312919234">判定阈值 T：R&lt;=T 为通过</p>
    <ul id="ul68032315817"><li>粗检模式：T==1e-2</li><li>自检模式：T==1e-3</li></ul>
    </td>
    </tr>
    </tbody>
    </table>

    当前工具基于以下方式生成检测结果。

    1.  统计待测数据（\*pass\_\*/\*.data）中绝对值不大于1e-6但基准数据（tensor\_graph/\*.data）大于1e-6的数量，记为N\_zero。
    2.  给定误差阈值T，对于两组数据中绝对值均大于1e-6的值，逐点（elementwise）统计相对误差、绝对误差均大于T的数值占总数据量的比例，记为R。
    3.  如果N\_zero <= 1000，且 R<=T，则判定误差在接受范围内。

5.  后续处理建议。

    建议收集相关结果信息，并提交ISSUE进行处理。

## 粗检操作步骤

1.  开启精度调试开关。（基础用例：examples/01\_beginner/00\_introduction/add\_direct.py）

    ```python
    ...
    verify_options = {
        "enable_pass_verify": True,
        ...
    }
    
    @pypto.jit(verify_options=verify_options)
    def add_kernel(input0: pypto.Tensor, input1: pypto.Tensor, output: pypto.Tensor):
        pypto.set_vec_tile_shapes(1, 16, 1, 64)
        output[:] = input0 + input1
    
    def add(input_data0, input_data1, output_data):
        ...
    
    def test_add():
        shape = (1, 16, 1, 64)
        input_data0 = torch.rand(shape, dtype=torch.float)
        input_data1 = torch.rand(shape, dtype=torch.float)
        output_data = torch.zeros(shape, dtype=torch.float)
        torch_add = torch.add(input_data0, input_data1)
        pypto.set_verify_golden_data(goldens=[None, None, torch_add])
    
        input_data0 = input_data0.to('npu')
        input_data1 = input_data1.to('npu')
        output_data = output_data.to('npu')
    
        add(input_data0, input_data1, output_data)
    ...
    ```

2.  执行修改后用例。

    ```bash
    python3 examples/01_beginner/00_introduction/add_direct.py 
    ```

3.  打印类似以下输出，指示对应的自检结果为通过（PASS）、未通过（FAIL\(ED\)）或跳过校验（NO\_COMPARE）：

    ```txt
    2025-mm-dd HH:MM:SS:xxx V | tensor_graph Verify for 3 data view list index 0 result NO_COMPARE
    2025-mm-dd HH:MM:SS:xxx V | tensor_graph Verify for 3 data view list index 1 result NO_COMPARE
    2025-12-17 22:18:49.013 V | tensor_graph Verify for 3 data view list index 2 result PASS
    ```

4.  执行结束后，在$\{work\_path\}/output/output\_\*/目录（\*代表时间戳）下生成verify\_\*目录，存放检测结果文件。

    ```txt
    ├── tensor_graph # 保存前端初始计算图模拟计算后的输入、输出数据，供后续人工分析
    │   ├── tensor_Incast_0.data 
    │   ├── tensor_Incast_1.data 
    │   ├── tensor_OUT_0.data 
    │   └── ...
    ├── verify_result.csv # 结果报告，用于保存对以上数据进行粗检的结果
    ```

5.  后续处理建议。

    对于结果中标记FAIL的情况，建议：

    1.  多方评审检查PyPTO前端代码的正确性。
    2.  在前端代码无明显异常的前提下，尝试[人工调测步骤](#section5342816216)。

## 人工调测步骤

1.  开启精度调试开关。（基础用例：examples/01\_beginner/00\_introduction/add\_direct.py）

    ```python
    ...
    verify_options = {
        "enable_pass_verify": True,
        ...
    }
    
    @pypto.jit(verify_options=verify_options)
    def add_kernel(input0: pypto.Tensor, input1: pypto.Tensor, output: pypto.Tensor):
        pypto.set_vec_tile_shapes(1, 4, 1, 64)
        pypto.pass_verify_save(input1, "input1_by_pass_verify")
        pypto.pass_verify_print(input0)
        output[:] = input0 + input1
    
    def add(input_data0, input_data1, output_data):
        ...
    
    def test_add():
        input_data0 = torch.rand(shape, dtype=torch.float, device='npu')
        input_data1 = torch.rand(shape, dtype=torch.float, device='npu')
        output_data = torch.zeros(shape, dtype=torch.float, device='npu')
        torch_add = torch.add(input_data0, input_data1)
    
        add(input_data0, input_data1, output_data)
    ...
    ```

2.  执行修改后用例。

    ```bash
    python3 examples/01_beginner/00_introduction/add_direct.py 
    ```

3.  打印类似以下输出，指示 input0 所保存的部分参考数据。

    ```txt
    input0:<64x64xFP16/64x64xFP16>
    [[0.03955 0.6094 0.1519 ... 0.7339 0.8789 0.8662]
     [0.6284 0.01465 0.6333 ... 0.2422 0.03516 0.8423]
     [0.231 0.02686 0.6055 ... 0.7466 0.2529 0.2231]
     ...
     [0.3477 0.4243 0.05273 ... 0.9287 0.1138 0.5083]
     [0.05273 0.9941 0.4985 ... 0.8345 0.8613 0.188]
     [0.3184 0.8047 0.833 ... 0.7734 0.2578 0.1392]]
    ```

4.  执行结束后，在$\{work\_path\}/output/output\_\*/目录（\*代表时间戳）下生成tensor/目录，存放指定保存的数据文件及对应元数据。

    ```txt
    ├── tensor/
    │   ├── input1_by_pass_verify.data     # 保存的指定模拟计算数据，格式为Tensor数据的直接内存转储
    │   ├── input1_by_pass_verify.csv      # 模拟计算数据的元数据，包括数据类型、shape信息
    ```

5.  后续处理建议。

    根据元数据信息使用常用的torch.from\_file\(\)、numpy.load\(\)等接口打开数据文件并转换为可解析的数值，再进一步进行通常开发者使用的数据分析方法，例如：检查异常数据的偏移规律、异常数据的值特征（inf/nan/zero 等）。

